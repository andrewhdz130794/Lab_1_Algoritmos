# -*- coding: utf-8 -*-
"""bisection_newton.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N0bVAnw9RX7n6Omjsv-2nVwIQPKv0DIz
"""

import numpy as np

def bisection_method(f, a, b, tol=1e-12, max_iter=1000):
    if f(a) * f(b) >= 0:
        raise ValueError("La funci贸n debe cambiar de signo en el intervalo [a, b].")
    
    iter_data = []
    k = 0
    xk = (a + b) / 2.0
    
    while k < max_iter and abs(f(xk)) > tol:
        iter_data.append((k, xk, abs(f(xk))))
        
        if f(a) * f(xk) < 0:
            b = xk
        else:
            a = xk
        
        k += 1
        xk = (a + b) / 2.0
        
    iter_data.append((k, xk, abs(f(xk))))
    return xk, iter_data

def newton_raphson_method(f, df, x0, tol=1e-12, max_iter=1000):
    iter_data = []
    xk = x0
    k = 0
    
    while k < max_iter and abs(f(xk)) > tol:
        iter_data.append((k, xk, abs(f(xk))))
        
        xk = xk - f(xk) / df(xk)
        k += 1
        
    iter_data.append((k, xk, abs(f(xk))))
    return xk, iter_data

# Funci贸n del problema de optimizaci贸n
def f(x):
    return x**2 + np.exp(-x)

# Derivada de la funci贸n
def df(x):
    return 2*x - np.exp(-x)
